#lang racket


(require "pages-to-parsed.rkt"
         "extras.rkt"
         "all-data.rkt")

(define (as-int s)
  (* 1000 (string->number/0 s)))

(define (to-int s)
  (inexact->exact (* 1000 (string->number/0 s))))

(define all-instructors
  (remove-duplicates
   (apply
    append
    (for/list ([q parsed-qtrs]
               [qtr qtr-nums])
      (apply
       append
       (for/list  ([dept (parsed-depts q)])
         (for/list ([instr (dept-instructors dept)]
                    #:when (home-record? instr))
           (define hdr (instructor-header instr))
           (define soc (match (col-ref 'id hdr)
                         [(regexp #px"0 (.*)" (list dc soc)) soc]))
           (list (col-ref 'name hdr)
                 (col-ref 'name hdr)
                 soc))))))))

(define (spit-out-instructors)
  (spit-out-data "/tmp/instructors.txt" all-instructors))

(define all-instructor-statuses
  (apply
   append
   (for/list ([q parsed-qtrs]
              [qtr qtr-nums])
     (apply
      append
      (for/list  ([dept (parsed-depts q)])
        (for/list ([instr (dept-instructors dept)]
                   #:when (home-record? instr))
          (define hdr (instructor-header instr))
          (list
           (instructor-name instr)
           qtr
           (dept-name dept)
           (as-int (col-ref 'tsf hdr))
           (as-int (col-ref 'iaf hdr))
           (as-int (col-ref 'osf hdr))
           (col-ref 'adm-lvl hdr)
           (col-ref 'rank hdr))))))))

(define (spit-out-instructor-statuses)
  (spit-out-data  "/tmp/instructorstatuses.txt" all-instructor-statuses))

;; all of the courses over all of the quarters
(define all-courses
  (apply 
   append   
   (for/list ([q parsed-qtrs]
              [qtr qtr-nums])
     (for*/list  ([dept (parsed-depts q)]
                  [instr (dept-instructors dept)]
                  [course (instructor-courses instr)]
                  #:when (not (special? course)))
       course))))

(define all-classifications
  (remove-duplicates
   (apply 
    append
    (for/list ([course (in-list all-courses)])
      (col-ref 'classification course)))))

;; the names (e.g.: '("CSC" "0123")
(define all-course-names
  (remove-duplicates
   (for/list ([course (in-list all-courses)])
     (list (col-ref 'dept course)
           (col-ref 'course-num course)))))

(define (spit-out-data filename records)
  (with-output-to-file filename
    (lambda ()
      (for ([c (in-list records)])
        (display (apply ~a (append (add-between c "\t") (list "\n"))))))))

(define (spit-out-course-names)
  (spit-out-data "/tmp/courses.txt" all-course-names))

(define all-subjects
  (remove-duplicates (map list (map first all-course-names))))

(define (spit-out-subjects)
  (spit-out-data "/tmp/subjects.txt" all-subjects))

(define all-specials
  (apply
   append
  (for/list ([q parsed-qtrs]
             [qtr qtr-nums])
    (for*/list  ([dept (parsed-depts q)]
                 [instr (dept-instructors dept)]
                 [course (instructor-courses instr)]
                 #:when (special? course))
      (when (not (string=? (col-ref 'scu course) ""))
        (error))
      (when (not (string=? (col-ref 'faculty-contact-hours course) ""))
        (error))
      (list ""
            (instructor-name instr)
            qtr
            (inexact->exact
             (* 1000 (string->number/0 (col-ref 'direct-wtu course))))
            (inexact->exact
             (* 1000 (string->number/0 (col-ref 'indirect-wtu course))))
            (col-ref 'special course))))))

(define (spit-out-specials)
  (spit-out-data "/tmp/specialcredits.txt" all-specials))


;; no datapoints; can't confirm that specials can occur for a person in 
;; more than one department report.
#;(for ([q parsed-qtrs]
      [qtr qtr-nums])
  (define table
    (group-by 
     (remove-duplicates
      (for*/list  ([dept (parsed-depts q)]
                   [instr (dept-instructors dept)]
                   [course (instructor-courses instr)]
                   #:when (special? course))
        (list (instructor-name instr)
              (dept-name dept))))
     first))
  (for ([(k v) (in-hash table)])
    (when (< 1 (length v))
      (display (~a "got one: " v)))))


(define in-groupings
  (apply 
   append
   (for/list ([q parsed-qtrs]
              [qtr qtr-nums])
     (remove-duplicates  
      (for*/list  ([dept (parsed-depts q)]
                   [instr (dept-instructors dept)]
                   [course (instructor-courses instr)]
                   #:when (not (special? course))
                   #:when (not (string=? "" (col-ref 'group-code course))))
        (list qtr 
              (col-ref 'dept course) 
              (col-ref 'course-num course)
              (col-ref 'section course)
              (col-ref 'group-code course)))))))

(define (spit-out-in-groupings)
  (spit-out-data "/tmp/in-groupings.txt" in-groupings))

(define groupings
  (remove-duplicates
   (for/list ([ig (in-list in-groupings)])
     (list (fifth ig) (first ig)))))

(define (spit-out-groupings)
  (spit-out-data "/tmp/groupings.txt" groupings))



;; ensure all elements are the same, return the first
;; (forall A . (nonempty-listof A) -> A)
(define (ensure-same l)
  (unless (cons? l)
    (raise-argument-error 'ensure-same "nonempty list" 0 l))
  (unless (andmap (lambda (elt) (equal? elt (first l))) l)
    (raise-argument-error 'ensure-same "list of identical elements" 0 l))
  (first l))

;; find the single classification for a course
(define (course-classification course)
  (ensure-same (remove-empties (col-ref 'classification course))))

(define (remove-empties l)
  (filter (lambda (elt) (not (string=? elt ""))) l))

(define all-offerings
  (apply
   append
   (for/list ([q parsed-qtrs]
             [qtr qtr-nums])
    (apply
     append
     (for*/list  ([dept (parsed-depts q)]
            [instr (dept-instructors dept)]
            #:when (home-record? instr))
      (for/list ([course (instructor-courses instr)]
            #:when (not (special? course)))
        (define classification 
          (course-classification course))
        (define corrected-classification
          (cond [(is-senior-project? course) "36"]
                [else classification]))
        (append
         (list qtr)
         (map 
          (lambda (col)
            (col-ref col course))
          '(dept
            course-num
            section
            discipline
            level
            enrollment))
         (list classification
               corrected-classification
               (apply + (map to-int (col-ref 'a-ccu course))))
         (map 
          (lambda (col)
            (first (col-ref col course)))
          '(days
            time-start
            time-stop))
         (list (to-int (first (col-ref 'tba-hours course)))
               (first (col-ref 'facility course))
               (first (col-ref 'space course))))))))))

(define (spit-out-offerings)
  (spit-out-data "/tmp/offerings.txt" all-offerings))

(define (spit-out-groupings-relation)
  (with-output-to-file "/tmp/groupings-relation.txt"
    (lambda ()
      (define groupings
        (apply 
         append
         (for/list ([q parsed-qtrs]
                    [qtr qtr-nums])
           (remove-duplicates  
            (for*/list  ([dept (parsed-depts q)]
                         [instr (dept-instructors dept)]
                         [course (instructor-courses instr)]
                         #:when (not (special? course))
                         #:when (not (string=? "" (col-ref 'group-code course))))
              (list qtr 
                    (col-ref 'dept course)
                    (col-ref 'course-num course)
                    (col-ref 'section course)
                    (col-ref 'group-code course)))))))
      (for ([g groupings])
        (display (apply ~a (add-between g "\t")))
        (newline)))))

(define (corrected course)
  (cond 
    [(and (has-group? course)
          (is-senior-project? course))
     (error 'corrected-dwtus
            "can't deal with senior project courses"
            " that also have group codes.")]
    [(is-senior-project? course)
     (list 36
           (* (string->number
               (col-ref 'enrollment course))
              (string->number
               (col-ref 'team-teaching-frac course))
              1/3))]
    [else
     (list (string->number/0 (course-classification course))
           (string->number/0 (col-ref 'direct-wtu course)))]))

(define all-offerseqs
  (apply
   append
   (for/list ([q parsed-qtrs]
             [qtr qtr-nums])
    (apply
     append
    (for*/list  ([dept (parsed-depts q)]
                 [instr (dept-instructors dept)]
                 #:when (home-record? instr))
      (for/list ([course (instructor-courses instr)]
                 #:when (not (special? course)))
        (define seqnums (col-ref 'sequence course))
        (define good-idx
          (for/first ([seqnum (in-list seqnums)]
                      [i (in-naturals)]
                      #:when (regexp-match 
                              #px"^\\*" seqnum))
            i))
        (match-define (list newclass newdwtus)
          (corrected course))
        (append
         (list qtr)
         (map 
          (lambda (col)
            (col-ref col course))
          '(dept
            course-num
            section))
         (list 
          (second (regexp-match #px"^\\*(\\d*)$" 
                                (list-ref seqnums good-idx))))
         (list (instructor-name instr))
         (map 
          (lambda (col)
            (inexact->exact
             (round (* 1000 (string->number/0 (col-ref col course))))))
          '(team-teaching-frac
            scu
            faculty-contact-hours
            direct-wtu))
         (list newclass
               (inexact->exact
                (round (* 1000 newdwtus)))
               (list-ref (col-ref 'facility-type course)
                         good-idx)))))))))

(define (spit-out-offerseqs)
  (spit-out-data "/tmp/offerseqs.txt" all-offerseqs))


#;(spit-out-groupings-relation)
#;(spit-out-offerseqs)

